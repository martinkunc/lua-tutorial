[{"id":0,"href":"/lua-tutorial/docs/01-installation/","title":"01. Installation","section":"Docs","content":"\rInstalling Lua interpreter\r#\rIf you want a standalone Lua interpreter, you can install binary using any of these ways:\nTo install Lua on MacOS\nbrew install lua To install on Windows, you can download the installer from Lua for Windows: luaforwindows\nif you are using chocolatey, you can use unofficial version from it by typing:\nchoco install lua To install on linux, the best is use your package manager. On Ubuntu:\nsudo apt install lua5.3 Editors and IDE\r#\rYou can use any editor. Lua has extension for Visual Studio Code or Sublime Text. There is also a full IDE ZeroBrane Studio.\n"},{"id":1,"href":"/lua-tutorial/docs/02-introduction/","title":"02. Introduction","section":"Docs","content":"\rVariables\r#\rVariable is a simple container for values. It can be assigned a value with = operator. Special value for empty value is nil, which signifies no value. For efficiency, you might want to assign nil to variable after its use to remove its previous value. s = \u0026#34;Hello Lua\u0026#34; a = 10 print(s, a) Execute \u0026raquo; Printing value of variables\r#\rLua has few built-in functions. To print a numeric or string value or a variable we can use function print().\nA single statement doesn\u0026rsquo;t have to end with a semicolon, but you can be use it separate two statements on the same line, even though it is also optional.\ns = \u0026#34;Pi is\u0026#34; p = 3.14 print(s, p) Execute \u0026raquo; Comments\r#\rComments in Lua can be either single line, when a line starts with two dashes --. When a comments needs to span multiple lines, it can be placed among --[[ ]].\n-- There wont be any output here --[[ print(\u0026#34;multiple\u0026#34;) print(\u0026#34;lines\u0026#34;) ]] Execute \u0026raquo; "},{"id":2,"href":"/lua-tutorial/docs/03-types/","title":"03. Types","section":"Docs","content":"\rLua variable types\r#\rLua is dynamically typed language, so any variable will have type based on value assigned to it.\nLua has eight basic types: number, string, boolean, table, userdata, function, thread and nil.\nNumbers\r#\rNumbers in Lua are only double precision floating point numbers, it doesn\u0026rsquo;t have integer numbers. Numbers can be specified also using scientifiec notation: print(3, 3.14, 314e-2) Execute \u0026raquo; Booleans\r#\rBooleans can be either true or false.\nStrings\r#\rString values are created with either double or single quotation marks. Strings in LUA are immutable, so characters inside string cannot be changed once a string is created, but you can create a new string with the change. Lua doesn\u0026rsquo;t have specific character type for single character. To insert a quotation mark inside a string you can use backslash escape character and there are few other escape characters as well: print(\u0026#34;backslash \\\\\u0026#34;) print(\u0026#34;new \\n line\u0026#34;) print(\u0026#34;double quotas\\\u0026#34;\u0026#34;) Execute \u0026raquo; Tables\r#\rA table is a collection of values in a variable with an index. In other programming languages it is called Array, Dictionary or Map. To create a new array we use brackets like this:\narray = {} It is important to mention that in Lua, tables by convention starts from one. Strings starts from 1, unlike from zero like in many other languages.\na = \u0026#39;text\u0026#39; b = 123 c = {5} print(\u0026#34;String \u0026#34;,a) print(\u0026#34;Number \u0026#34;, b) print(\u0026#34;Table value at index 1\u0026#34;, c[1]) Execute \u0026raquo; Userdata and threads\r#\rUserdata are typically used to transfer custom data from C Api. Thread is a operating system concept to start some subprogram with concurrent execution, for example play some music while program is running.\nType operator\r#\rBuilt in function type can return string identifying the type of variable passed as an argument.\nprint(type(\u0026#34;Hello world\u0026#34;)) --\u0026gt; string print(type(10.4*3)) --\u0026gt; number print(type(print)) --\u0026gt; function print(type(type)) --\u0026gt; function print(type(true)) --\u0026gt; boolean print(type(nil)) --\u0026gt; nil print(type(type(X))) --\u0026gt; string Execute \u0026raquo; "},{"id":3,"href":"/lua-tutorial/docs/04-chunks-and-require/","title":"04. Chunks and require","section":"Docs","content":"\rCode chunks\r#\rLua executes its code in blocks of statements, called chunks. Lua interpreter can execute statement from interactive mode, or load the chunk from a file. Lua interpreter compiles the statements to a byte code, which is then executed.\nYou can execute a statement directly as parameter of Lua interpreter using -e switch like this:\nlua -e \u0026#34;print(\u0026#39;Hello world\u0026#39;)\u0026#34; Lua chunk can be a file with .lua extension, created in any text editor. After saving it can be executed in the lua interpreter using -l command line switch. For example:\nlua -l helloworld.lua Note: space after -l is optional.\nBecause the file is just one of chunks executed by Lua interpreter, you can execute many of chunks from different files using.\nFor example, when you have file file1.lua with content:\ns = \u0026#34;Hello world\u0026#34; and another file file2.lua with content:\nprint(s) Then you can load both chunks (Lua will use require) and last switch \u0026ldquo;-e\u0026rdquo; will make Lua interpreter exit after printing content of variable set in first chunk.\n% lua -lfile1 -lfile2 -e \u0026#34;os.exit(1)\u0026#34; Hello world Require statement\r#\rBecause chunks of statements might need another file or a lua module, Lua has function require. It tries to find the file in Lua Path and if it wasn\u0026rsquo;t loaded yet, it loads it. Now, lets consider we still have file1.lua which sets variable s to \u0026ldquo;Hello World\u0026rdquo;. We can create another file, for example called use_file1.lua with content:\nrequire(\u0026#34;file1\u0026#34;) print(s) Where the require function checks if module \u0026ldquo;file1\u0026rdquo; is already loaded, eventually loads it. The consequent print will reuse the defined variable and prints its content, so that output of this command will be Hello World. The command to execute with output:\n% lua -l use_file1 -e \u0026#34;os.exit(1)\u0026#34; Hello world Please note, that when loading a module with -l or require function, we dont specify the .lua extension. It is because of how Lua is resolving modules.\nLua first check if environment variable LUA_PATH exists, if it does, tries to extract path patterns from it. The file patterns is a list of paths to search for modules where ? can be used instead of part of file name. Standard paths which Lua searches in can be printed by:\n% lua -e \u0026#34;print(package.path)\u0026#34; /usr/local/share/lua/5.4/?.lua;/usr/local/share/lua/5.4/?/init.lua;/usr/local/lib/lua/5.4/?.lua;/usr/local/lib/lua/5.4/?/init.lua;./?.lua;./?/init.lua It is semicolon separated list of patterns. Most interestring is \u0026ldquo;./?.lua\u0026rdquo; which searches for file name specified in require (instead of ?) with .lua extension in current working directory.\nDofile function\r#\rSimilarly to require, dofile is a function which loads chunk of statements. But it doesn\u0026rsquo;t search for file in Lua Path. Because of this, extension is required. Also, dofile doesn\u0026rsquo;t check whether the file was loaded and loads it again always.\nTo execute same two chunks as we used above, we can use dofile like this:\n% lua -e \u0026#34;dofile(\u0026#39;file1.lua\u0026#39;) dofile(\u0026#39;file2.lua\u0026#39;) os.exit(1)\u0026#34; Hello world "},{"id":4,"href":"/lua-tutorial/docs/05-string-functions/","title":"05. String functions","section":"Docs","content":"\rMultiline string literals\r#\rTo set even very long strings, the literal can be placed among two square brackets [[\u0026hellip;]]. html = [[ \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ]] print(html) Execute \u0026raquo; String conversion\r#\rWhenever a string is used in an expression together with a number, Lua will attempt to convert string to its numerical value so that expression could have been evaluated. When this is not expected, it can lead to misleading result. print(\u0026#34;10\u0026#34;*2) print(\u0026#34;1\u0026#34;\u0026#43;\u0026#34;2\u0026#34;) Execute \u0026raquo; Please note that equality check with == will return false, because types doesn\u0026rsquo;t match. print(\u0026#34;1\u0026#34; == 1) Execute \u0026raquo; When this doesn\u0026rsquo;t succeed, it produces an Error. print(\u0026#34;one\u0026#34;\u0026#43;2) Execute \u0026raquo; Concatenation with ..\r#\rFor concatenate (join) two strings in a new string, use two dots ... This will prevent string conversion. Please note that used after a number, it needs to be separated by a space to distinguish it from a decimal point. Following code mixes non-space separated concatenation with separated for use after a number. print(\u0026#34;Day: \u0026#34;..1) print(type(1 .. 23 .. 45)) Execute \u0026raquo; Convert to number with tonumber\r#\rTo convert a string to a number, use tonumber. The function results in nil when the parameter is not a number. print(type(\u0026#34;123\u0026#34;)) print(type(tonumber(\u0026#34;456\u0026#34;))) print(tonumber(\u0026#34;two\u0026#34;)) Execute \u0026raquo; Get length of a string with # or len\r#\rTo find the number of characters in a string, Lua has special operator # used before the string. The followign example prints 3.\nlength = #\u0026#34;abc\u0026#34; print(length) The string library also defines metafunction __len for string. We will conver metafunctions later. The use is stringVar:len() or stringVar.len(stringVar) or string.len(stringVar). s = \u0026#34;abc\u0026#34; length1 = #s length2 = s.len(s) length3 = string.len(s) print(s, length1, length2, length3) Execute \u0026raquo; "},{"id":5,"href":"/lua-tutorial/docs/06-arrays/","title":"06. Arrays and tables","section":"Docs","content":"\rLua Arrays\r#\rThe Lua multi-purpose data type table is a base for Arrays. It is a collection of values with an index. To create a new array, we can use brackets {}. Arrays can grow dynamically, because they are based on tables. To set or get a value on a specific index, we use square brackets [] with index: [1] will return element at index 1 or nil if it doesn\u0026rsquo;t exist. Arrays can start from 0 or 1 or any other value. It is a convention to start arrays at index 1 and Lua libraries follows this convention. To insert a new value, we can assign new value to new index. A new array can be initialized with a literal in brackets.\na = {} a[2] = 1 odd = {1, 3, 5, 7} print(a[1], a[2]) print(odd[1], odd[2]) Execute \u0026raquo; Lua tables\r#\rData Type Table can not only be used for arrays with an integer index, but this concept is broad in Lua world. Instead of using numeric index, the index can be a string (or any other value except nil), like this:\na = {} a[\u0026#34;name\u0026#34;] = \u0026#34;Bob\u0026#34; print(a[\u0026#34;name\u0026#34;]) Execute \u0026raquo; Tables are implemented as associative arrays in other languages it is known as Dictionaries or Maps. They string index is called also a key and it must be unique (like the numeric index).\nBecause Lua uses tables a lot, it allows to refer to keys in the table also using without square brackets, like this:\na.name = \u0026#34;Bob\u0026#34; Tables are reference types, so assigning a table to another variable will reflect consequent changes on both places, because they are sharing same reference table.\nhobbit = {} hobbit.name = \u0026#34;Bilbo\u0026#34; invisibleHobbit = hobbit print(invisibleHobbit.name) Execute \u0026raquo; Lua tables can be also used as records and table initialization supports also construction with providing named fields. The table keys are also case sensitive. For example:\nperson = {Name=\u0026#34;John\u0026#34;, Lastname = \u0026#34;Doe\u0026#34;} print(person.Name, person.Lastname) Execute \u0026raquo; Lua tables as packages\r#\rLua uses tables to organize libraries loaded by require into packages. For example math.pi refers to Pi value declared in library math, which is automatically loaded by Lua and added to global scope.\nprint(math.pi) Execute \u0026raquo; Lua table indexes as variables\r#\rTable keys, or indexes can be also evaluated from a variable. In next example, we store two different values to different keys based on actual k value.\nchild = {} k = \u0026#34;age\u0026#34; child[k] = 5 k = \u0026#34;sleeping\u0026#34; child[k] = true print(child.age, child.sleeping) Execute \u0026raquo; "},{"id":6,"href":"/lua-tutorial/docs/07-if-condition-operators/","title":"07. If condition and operators","section":"Docs","content":"\rIf condition\r#\rTo introduce logical decision to your Lua program, we can use if condition, which is very similar to how it works in other programming languages.\nIts basic form is\nif \u0026lt;condition\u0026gt; then statement end This form evaluates the condition, which can be logical or relational expression and when it is evaluated as true, executes one or more statements after then keyword.\nIt might also have else branch, which has the form of:\nif \u0026lt;condition\u0026gt; then statement else other_statement end where the part after else is executed only when the condition is false.\nAnd finally when we would need to evaluate multiple different cases, we could use elseif form in form format:\nif \u0026lt;condition\u0026gt; then statement elseif \u0026lt;another_condition\u0026gt; other_statement else another_statement end This syntax will evaluate elseif branch when first condition didnt\u0026rsquo; succeeded and when another_condition is true, executes its block. It might have multiple elseif branches (and their order is significant). Please note that multiple branches doesn\u0026rsquo;t close with end, only the whole statement does.\nFinally there can be only one else, which executes in all cases where if or elseif conditions weren\u0026rsquo;t true.\nArithmetic operators\r#\rTo evaluate any arithmetic expression, we can use usual operators +, -, * and / and unary -. Additionally, it has n-th power operator ^ used like square = side^2 or side = square^(1/2) and obviously brackets. The precedences are following usual BIDMAS predecences. Additionally, Lua supports modulo, (the remainder after division) % with syntax evenModulo = n%2 evaluating to 0 for even and 1 for odd n.\nRelational operators\r#\rAlso usual relational operators \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= are supported. Relational equals is == and not equals has unusual ~=.\nWe can use relational operators with any types. If they don\u0026rsquo;t match, Lua considers them not to be equal.\nSpecial case is the nil type, which is not equal to anything except other nil.\nWhen comparing two reference types like tables, userdata and functions, Lua compares their reference, so they are only equal if they points to the same object.\nThe strings are compared by alphabetical order (with currently set locale). Other types like tables, userdata and functions can only be compared for equality or nonequality.\nSpecial cases are when comparing mixed types. For example \u0026quot;1\u0026quot;==1 is false because of different types, and \u0026quot;10\u0026quot;\u0026lt;\u0026quot;2\u0026quot; is true because it uses lexical comparism.\nIn contract to equals or non equals, which can be used to any types, Lua will result in an error when we attempt to use other relational operators, like \u0026gt; or \u0026lt; with incompatible types, like in this case: \u0026quot;1\u0026quot; \u0026lt; 2.\nLogical operators\r#\rLua has well know logical operators and, or and not. They behave differently based on context how they are used.\nWhen they are used as logical expression (evaluating true or false values), they result in true or false, but then they are used as statements, they return values from left or right side based on result of the evaluation.\nNot has the highest precedence, and has lower precedence and or has it lowest.\nThe operator and when evaluated as non logical expression, returns its first argument when whole expression is false and when its true it returns the second argument.\nThe or operator when used as logical expression returns its first argument when the expression is not false, and when it is false, returns its second argument.\nIn Lua, false or nil are considered false and anything else is considered true.\nif true and false then print(\u0026#39;never prints\u0026#39;) end if true then print(\u0026#39;always prints\u0026#39;) end -- false and anything is false -- so returns first argument false print(false and 123) -- nil and anything is false -- so returns first argument nil print(nil and 123) -- number and other number is true -- so returns second argument 2 print(1 and 2) -- false and anything is false -- so or returns second argument 2 print(false or 2) -- nil and anything is false -- so or returns second argument 2 print(nil or 2) -- anything else then nil or false is true -- so or returns first argument 1 print(1 or 2) Execute \u0026raquo; Usual construction relying on nil being false is specifying default value using expression value or default if an variable has initial nil value with syntax:\n-- nil or false are false a = nil v = a or 10 print(v) -- prints 10 a = false v = a or 10 print(v) -- prints 10 -- or of not false returns first argument a = 5 v = a or 10 print(v) -- prints 5 Execute \u0026raquo; Because anything else than nil or false is true, the actual expression A and B can be used to return B only when expression A is true.\nThe logical expression evaluation is also used for ternary operator in Lua. The idea is that expression (a and b) or c or because and has higher priority, it can be simplified as:\na and b or c is an equivalent to\na ? b : c for example:\nmax = (x \u0026gt; y) and x or y This is because x \u0026gt; y is boolean expression and and results in first argument (true or false) when any logical expression and anything results in first argument. That used as left side of or makes it return its left side (x here) when it is not false.\nThe not operator always results in true or false.\nExample of if statement with multiple branches:\na = 18 if a \u0026lt; 18 then print(\u0026#34;Teenager\u0026#34;) elseif a \u0026gt;= 18 and a \u0026lt; 65 then print(\u0026#34;Adult\u0026#34;) else print (\u0026#34;Senior person\u0026#34;) end Execute \u0026raquo; "},{"id":7,"href":"/lua-tutorial/docs/08-functions-local-and-global-scope/","title":"08. Functions, local and global scope","section":"Docs","content":"\rFunctions\r#\rInstead of repeating some code block, or calling a dofile multiple times, we can use a function, which is an abstraction to structure a block of code.\nThese blocks are the same, except the variable n n = \u0026#34;Alice\u0026#34; s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) n = \u0026#34;Bob\u0026#34; s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) Execute \u0026raquo; It can be extracted into a function and give it a name SayHello and parameter n Because the functions contain multiple statements we need to use end keyword to indicate end of function. Function starts with function keyword, then its name and in parenthesis can be list of parameters for it. function SayHello(n) s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) end Execute \u0026raquo; Note: We will cover anonymous functions later.\nIf we execute this block alone, nothing will happen, because we have only declared (specified) the function and its statements, but we didn\u0026rsquo;t started it from anywhere. To call a function, we just type its name and within parenthesis provide a value for the parameters. function SayHello(n) s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) end SayHello(\u0026#34;Alice\u0026#34;) SayHello(\u0026#34;Bob\u0026#34;) Execute \u0026raquo; Local variables\r#\rActually the variable s in our function is a global variable. It means that it shares the value with the rest of the code even outside of the function block. That could lead to some unexpected variable changes when code is more complex. Instead, we can isolate variable to be only defined in the block of code. To do it, when we declare the variable we prefix it with local. For example:\nlocal s = \u0026#34;Hi, my name is\u0026#34; .. n Such a variable then won\u0026rsquo;t even exist outside of the function block, in the main program, or in another function. It is beneficial to use local variable as much as possible to prevent the variable clashes, but in Lua it needs to be explicitly expressed.\nGlobal variables and global scope\r#\rIf the local prefix is missing, the variable is considered global, which means it is shared among all blocks. The program which is not in any block is called global scope, in contrast code inside a function or other blocks is called local scope. Variables declared with local prefix exists only it its scope.\nIf you look at following code, you will see that variable s is at first outside of function. It wasn\u0026rsquo;t declared there, so at first it is nil. Later, from global scope we call function SayHello with parameter Alice, which sets variable from global scope to \u0026ldquo;Hi, my name is Alice\u0026rdquo; and because it is global scope variable, it will change its value even in main program and this texts is printed out. print(\u0026#34;Variable s in the beginning : \u0026#34;,s) function SayHello(n) s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) end SayHello(\u0026#34;Alice\u0026#34;) print(\u0026#34;Variable s after SayHello(Alice) : \u0026#34;,s) SayHello(\u0026#34;Bob\u0026#34;) print(\u0026#34;Variable s after SayHello(Bob) : \u0026#34;,s) Execute \u0026raquo; Lua Global scope table\r#\rIn Lua, The global scope variables and functions are stored in special built-in table, called underscore G _G. For example we can access global variable directly throught the _G using: name = \u0026#34;Jack\u0026#34; age = 51 print(_G.name, _G.age) Execute \u0026raquo; "},{"id":8,"href":"/lua-tutorial/docs/09-functions-with-multiple-results/","title":"09. Functions with multiple results","section":"Docs","content":"\rFunctions with multiple results\r#\rIn Lua, function can return none, one, or even multiple return values. It is not the same as if function returns a table, here its results are stored directly to result variables after the call. For example hypothetical function to attempt to withdraw money could result in either whole amount, or just a portion of requested cash and an boolean indication that not whole requested value was returned. Our function for simplicity always results in true.\nfunction TryWithdrawMoney(m) return m, true end amount, success = TryWithdrawMoney(100) print(amount, success) Execute \u0026raquo; Lua changes behaviour of how multiple results are being used, depending into how many result variables the result is assigned to match the expected count. For example following code will fill result based on produced number of results and the rest will be nil.\nfunction Produce0() return end function Produce1() return \u0026#34;a\u0026#34; end function Produce2() return \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34; end x,y,z = Produce0() print(x,y,z) x,y,z = Produce1() print(x,y,z) x,y,z = Produce2() print(x,y,z) Execute \u0026raquo; Similarly, we can combine the multiple results producing function with multiple results assignment.\nfunction Produce0() return end function Produce1() return \u0026#34;a\u0026#34; end function Produce2() return \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34; end x,y,z = 1, 2, Produce0() print(x,y,z) x,y,z = Produce1() print(x,y,z) x,y,z = Produce1(), 1, 2 print(x,y,z) Execute \u0026raquo; There is a convention in Lua, if function returns value, which I don\u0026rsquo;t want to use we assign it to variable underscore _.\nCreate multiple results from an array\r#\rLua\u0026rsquo;s unpack function can accept an array as argument and returns the values are multiple value results. Following with fill result variables:\nx,y,z = unpack({1, 2, 3}) print(x,y,z) Execute \u0026raquo; Calling function with multiple parameters\r#\rWhen a function has multiple parameters, we can also use unpack to deconstruct its array argument into the parameters for the function:\nfunction add(a, b) return a\u0026#43;b end a = {1,2} print(add(unpack(a))) Execute \u0026raquo; "},{"id":9,"href":"/lua-tutorial/docs/10-closures-iterators/","title":"10. Closures and Iterators","section":"Docs","content":"\rReturn function from a function\r#\rA function result can also be a new function. This could be usefull when I dont want to immediatelly execute some code, but instead just provide a mechanism to create customized function to be evaluated later in my code. Typically such a function doesn\u0026rsquo;t have name, its called anonymous.\nFor example function makeCurrentTime returns a function, which has no parameters, and when called, it just returns what is in global string hardCodedTime. It could be used to mock current time for testing for example.\nPlease note that such a returned function can be immadiatelly called by providing parameters in brackets, so the calling code has two sets of brackets. First creates function and second calls it.\nfunction makeCurrentTime() return function () return hardcodedTime end end hardcodedTime = \u0026#34;12:15\u0026#34; nowFunction = makeCurrentTime() t = nowFunction() print(\u0026#34;The time is \u0026#34;, t) hardcodedTime = \u0026#34;02:00\u0026#34; nowFunction = makeCurrentTime() t = nowFunction() print(\u0026#34;The time is \u0026#34;, t) print(\u0026#34;Concise call with extra brackets \u0026#34;,makeCurrentTime()()) Execute \u0026raquo; Access outer state from a closure function\r#\rThe function returned from another function could also return local variable from the function where it is defined, this is possible due to mechanism called closure. The variables still have the value, even if the originating function has already returned and they values can be changed, providing different behaviour upon consequent closure function calls.\nPlease note that to keep closure\u0026rsquo;s state we have to create closure function once, but can call it multiple times.\nfunction endlessIncreaser() local a = 0 return function () a = a \u0026#43; 1 return a end end increaser = endlessIncreaser() print(\u0026#34;calling endlessIncreaser() \u0026#34;, increaser()) print(\u0026#34;calling endlessIncreaser() \u0026#34;, increaser()) Execute \u0026raquo; Lua iterators\r#\rIterator is an interestring function, which could provide next value from a table, sequence, or based on completelly customized logic. In its nature it is abstraction which allows write even more complex way how to provide next value, which can be later reused by other code more easily. Iterators in Lua are functions, which based on passed state generate next state. For example endlessIncreaser used above is already an iterator. Later in chapter 12-cycles-for-while-pairs/ we will see concise way how to consume values created by iterators.\n"},{"id":10,"href":"/lua-tutorial/docs/11-table-key-value-pairs/","title":"11. Table Key value pairs","section":"Docs","content":"\rKey value pairs\r#\rWe have mentioned that in table values are indexed by keys. Lua provides functions to return key and value from specific index as multiple results.\nPairs and IPairs functions\r#\rThe built-in functions pairs and ipairs works with tables. They provide iterators for all keys and values in the provided table.\nThe key difference is in result which each iterator returns\npairs creates iterator which provides current key and value\nipairs provides two results, the current key (index) in the table and also the value on the key in the table\nStateless and statefull iterators\r#\rBoth pairs and iparis are examples of stateless operators. That means there is no hidden state and its execution is entirely driven by provided control variable (current key).\nExample of statefull operator is shown in chapter 09. Closures and Iterators in function endlessIncreaser, which remembers its state and doesn\u0026rsquo;t require control variable.\nStateless iterators have to continue from a certain point in the collection so to obtain next value from an iterator we need to provide it the current value. Usually the next returned value then becomes new current value.\nTo find the first item, initial iterator can be called without the current state and that is why number of arguments to iter differs in first call here:\na = {[1]=\u0026#34;I\u0026#34;, [2]=\u0026#34;II\u0026#34;, [3]=\u0026#34;III\u0026#34;} -- create iterator iter = pairs(a) print(\u0026#34;Calling iterator first time \u0026#34;) currentKey, currentValue = iter(a) print(currentKey, currentValue) print(\u0026#34;Calling iterator second time\u0026#34;) currentKey, currentValue = iter(a, currentKey) print(currentKey, currentValue) print(\u0026#34;Calling iterator third time\u0026#34;) currentKey, currentValue = iter(a, currentKey) print(currentKey, currentValue) print(\u0026#34;Calling iterator fourth time\u0026#34;) currentKey, currentValue = iter(a, currentKey) print(currentKey, currentValue) Execute \u0026raquo; Please note, that the order of keys is not guarantueed to match the constructor. If we would need the ordered enumeration, we would need to iterate over the index.\nThe following example gets iterator using ipairs and creates next index and value pair.\nThe problem with ipairs is that it can iterate the table only when keys are numbers, so it cannot be used with string keys.\nAnother limitation of ipairs is that you have to provide it with initial key, but that is returned as third result of ipairs.\nThe second result state is the invariant table being used to iterate over. This is usefull when the state of iteration is complex, so that the iterator can create control table with state, which would use to drive iterations together with control variable.\na = {[1]=\u0026#34;I\u0026#34;, [2]=\u0026#34;II\u0026#34;, [3]=\u0026#34;III\u0026#34;} iter, state, initial = ipairs(a) nextKey, nextValue = iter(a,initial) print(\u0026#34;1st call Key \u0026#34;, nextKey,\u0026#34; value \u0026#34;, nextValue) nextKey, nextValue = iter(a,nextKey) print(\u0026#34;2nd call Key \u0026#34;, nextKey,\u0026#34; value \u0026#34;, nextValue) nextKey, nextValue = iter(a,nextKey) print(\u0026#34;3nd call Key \u0026#34;, nextKey,\u0026#34; value \u0026#34;, nextValue) nextKey, nextValue = iter(a,nextKey) print(\u0026#34;4th call Key \u0026#34;, nextKey,\u0026#34; value \u0026#34;, nextValue) Execute \u0026raquo; "},{"id":11,"href":"/lua-tutorial/docs/12-for-cycle/","title":"12. For Cycle","section":"Docs","content":"\rCycle structures\r#\rSimilarly to other languages Lua has statement for controlling repetitive cycle which might have a variable to drive it and a condition at the beginning or end of the cycle.\nFor cycle\r#\rLua has two types of for cycles, numeric for and generic for.\nNumeric for cycle\r#\rTo execute some statement several times, without for cycle we would need to declare variable with initial value, adjust the variable for next value up the the maximal range and execute the defined block.\nFor cycle has following form, where newly declared local variable i will have values from 1 to 3 (inclusive).\nfor i=1, 3 do print(\u0026#34;*\u0026#34;, i) end Execute \u0026raquo; In this form, variable is incremented by one and if we want different increment, we can add it after the end of range. In this form, cycle will start with 3 and decrease down up to 1. for i=3, 1, -1 do print(\u0026#34;*\u0026#34;, i) end Execute \u0026raquo; Generic for cycle\r#\rIn Lua, generic for cycle is for iterating over iterators. The most common use case is to iterate over tables using function pairs or ipairs, which are providing built in iterators over tables. The syntax is as following:\na = {January=31,February=28, March=31} for k, m in pairs(a) do print(k..\u0026#34; has \u0026#34;..m..\u0026#34; days\u0026#34;) end Execute \u0026raquo; The ipairs is a limited variant, which doesn\u0026rsquo;t work on tables where keys aren\u0026rsquo;t numbers. It returns key (index) and value to the table.\nsuffixes = {[1]=\u0026#34;st\u0026#34;,[2]=\u0026#34;nd\u0026#34;,[3]=\u0026#34;rd\u0026#34;} a = {[1]=\u0026#34;January\u0026#34;,[2]=\u0026#34;February\u0026#34;,[3]=\u0026#34;March\u0026#34;} for i, v in ipairs(a) do print(i..\u0026#34; \u0026#34;..suffixes[i]..\u0026#34; month is \u0026#34;..v) end Execute \u0026raquo; The biggest advantage of generic for is that it can be used with any custom iterator function, which makes consuming iterators quite straightforward.\nWe could use function iterator limitedIncreaser which returns iterator which returns values from zero to the maximal value passed as its argument generic for this way:\nfunction limitedIncreaser(max) local a = 0 return function () a = a \u0026#43; 1 if (a ) return a end for v in endlessIncreaser() do print(k..\u0026#34; has \u0026#34;..m..\u0026#34; days\u0026#34;) end end Execute \u0026raquo; "},{"id":12,"href":"/lua-tutorial/docs/13-while-and-repeat-cycles/","title":"13. While and repeat cycles","section":"Docs","content":"\rWhile cycle\r#\rIn Lua, the while keyword is no surprise. It evaluates its invariant condition at the beginning and when its false, the cycle ends.\nThe syntax is:\nwhile \u0026lt;condition\u0026gt; do statement end For example:\nlocal n = 10 local a = n local b = 1 while a \u0026gt; 0 do b = b * a a = a - 1 end print(\u0026#34;Factorial of \u0026#34;..n..\u0026#34; is \u0026#34;..b) Execute \u0026raquo; When a number reaches maximal value, it becomes inf in Lua, that is maximal possible numeric value. It is defined as a constant in math.huge. Number will become inf when it is too large or when divided by zero. Similar constant is nan, for Not a number, which is when result of operation is not numeric. It can be for example result of 0/0\nYou can try to calculate factorial of 1000 and see what happens.\nRepeat cycle\r#\rAdditionally, Lua has also cycle with condition at the end. The repeat until cycle. The syntax is:\nrepeat statement until condition The cycle\u0026rsquo;s condition is evaluated after the execution of body, so the block is always executed at least once. The condition introduced by until is as expected negation of valid state, which you would put in the while-end condition.\nExample of factorial written using a repeat until:\nlocal n = 10 local a = n local b = 1 repeat b = b * a a = a - 1 until a \u0026lt;= 0 print(\u0026#34;Factorial of \u0026#34;..n..\u0026#34; is \u0026#34;..b) Execute \u0026raquo; "},{"id":13,"href":"/lua-tutorial/docs/15-common-standard-libraries-copy/","title":"15. Common standard libraries","section":"Docs","content":"\rPreloaded libraries\r#\rString library\r#\rTo set even very long strings, the literal can be placed among two square brackets [[\u0026hellip;]]. html = [[ \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ]] print(html) Execute \u0026raquo; String conversion\r#\rWhenever a string is used in an expression together with a number, Lua will attempt to convert string to its numerical value so that expression could have been evaluated. When this is not expected, it can lead to misleading result. print(\u0026#34;10\u0026#34;*2) print(\u0026#34;1\u0026#34;\u0026#43;\u0026#34;2\u0026#34;) Execute \u0026raquo; Please note that equality check with == will return false, because types doesn\u0026rsquo;t match. print(\u0026#34;1\u0026#34; == 1) Execute \u0026raquo; When this doesn\u0026rsquo;t succeed, it produces an Error. print(\u0026#34;one\u0026#34;\u0026#43;2) Execute \u0026raquo; Concatenation with ..\r#\rFor concatenate (join) two strings in a new string, use two dots ... This will prevent string conversion. Please note that used after a number, it needs to be separated by a space to distinguish it from a decimal point. Following code mixes non-space separated concatenation with separated for use after a number. print(\u0026#34;Day: \u0026#34;..1) print(type(1 .. 23 .. 45)) Execute \u0026raquo; Convert to number with tonumber\r#\rTo convert a string to a number, use tonumber. The function results in nil when the parameter is not a number. print(type(\u0026#34;123\u0026#34;)) print(type(tonumber(\u0026#34;456\u0026#34;))) print(tonumber(\u0026#34;two\u0026#34;)) Execute \u0026raquo; Get length of a string with # or len\r#\rTo find the number of characters in a string, Lua has special operator # used before the string. The followign example prints 3.\nlength = #\u0026#34;abc\u0026#34; print(length) The string library also defines metafunction __len for string. We will conver metafunctions later. The use is stringVar:len() or stringVar.len(stringVar) or string.len(stringVar). s = \u0026#34;abc\u0026#34; length1 = #s length2 = s.len(s) length3 = string.len(s) print(s, length1, length2, length3) Execute \u0026raquo; "}]