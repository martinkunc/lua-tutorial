[{"id":0,"href":"/lua-tutorial/docs/01-installation/","title":"01. Installation","section":"Docs","content":"\rInstalling Lua interpreter\r#\rIf you want a standalone Lua interpreter, you can install binary using any of these ways:\nTo install Lua on MacOS\nbrew install lua To install on Windows, you can download the installer from Lua for Windows: luaforwindows\nif you are using chocolatey, you can use unofficial version from it by typing:\nchoco install lua To install on linux, the best is use your package manager. On Ubuntu:\nsudo apt install lua5.3 Editors and IDE\r#\rYou can use any editor. Lua has extension for Visual Studio Code or Sublime Text. There is also a full IDE ZeroBrane Studio.\n"},{"id":1,"href":"/lua-tutorial/docs/02-introduction/","title":"02. Introduction","section":"Docs","content":"\rVariables\r#\rVariable is a simple container for values. It can be assigned a value with = operator. Special value for empty value is nil, which signifies no value. For efficiency, you might want to assign nil to variable after its use to remove its previous value. s = \u0026#34;Hello Lua\u0026#34; a = 10 print(s, a) Execute \u0026raquo; Printing value of variables\r#\rLua has few built-in functions. To print a numeric or string value or a variable we can use function print().\nA single statement doesn\u0026rsquo;t have to end with a semicolon, but you can be use it separate two statements on the same line, even though it is also optional.\ns = \u0026#34;Pi is\u0026#34; p = 3.14 print(s, p) Execute \u0026raquo; Comments\r#\rComments in Lua can be either single line, when a line starts with two dashes --. When a comments needs to span multiple lines, it can be placed among --[[ ]].\n-- There wont be any output here --[[ print(\u0026#34;multiple\u0026#34;) print(\u0026#34;lines\u0026#34;) ]] Execute \u0026raquo; "},{"id":2,"href":"/lua-tutorial/docs/03-types/","title":"03. Types","section":"Docs","content":"\rLua variable types\r#\rLua is dynamically typed language, so any variable will have type based on value assigned to it.\nLua has eight basic types: number, string, boolean, table, userdata, function, thread and nil.\nNumbers\r#\rNumbers in Lua are only double precision floating point numbers, it doesn\u0026rsquo;t have integer numbers. Numbers can be specified also using scientifiec notation: print(3, 3.14, 314e-2) Execute \u0026raquo; Booleans\r#\rBooleans can be either true or false.\nStrings\r#\rString values are created with either double or single quotation marks. Strings in LUA are immutable, so characters inside string cannot be changed once a string is created, but you can create a new string with the change. Lua doesn\u0026rsquo;t have specific character type for single character. To insert a quotation mark inside a string you can use backslash escape character and there are few other escape characters as well: print(\u0026#34;backslash \\\\\u0026#34;) print(\u0026#34;new \\n line\u0026#34;) print(\u0026#34;double quotas\\\u0026#34;\u0026#34;) Execute \u0026raquo; Tables\r#\rA table is a collection of values in a variable with an index. In other programming languages it is called Array, Dictionary or Map. To create a new array we use brackets like this:\narray = {} It is important to mention that in Lua, tables by convention starts from one. Strings starts from 1, unlike from zero like in many other languages.\na = \u0026#39;text\u0026#39; b = 123 c = {5} print(\u0026#34;String \u0026#34;,a) print(\u0026#34;Number \u0026#34;, b) print(\u0026#34;Table value at index 1\u0026#34;, c[1]) Execute \u0026raquo; Userdata and threads\r#\rUserdata are typically used to transfer custom data from C Api. Thread is a operating system concept to start some subprogram with concurrent execution, for example play some music while program is running.\nType operator\r#\rBuilt in function type can return string identifying the type of variable passed as an argument.\nprint(type(\u0026#34;Hello world\u0026#34;)) --\u0026gt; string print(type(10.4*3)) --\u0026gt; number print(type(print)) --\u0026gt; function print(type(type)) --\u0026gt; function print(type(true)) --\u0026gt; boolean print(type(nil)) --\u0026gt; nil print(type(type(X))) --\u0026gt; string Execute \u0026raquo; "},{"id":3,"href":"/lua-tutorial/docs/04-chunks-and-require/","title":"04. Chunks and require","section":"Docs","content":"\rCode chunks\r#\rLua executes its code in blocks of statements, called chunks. Lua interpreter can execute statement from interactive mode, or load the chunk from a file. Lua interpreter compiles the statements to a byte code, which is then executed.\nYou can execute a statement directly as parameter of Lua interpreter using -e switch like this:\nlua -e \u0026#34;print(\u0026#39;Hello world\u0026#39;)\u0026#34; Lua chunk can be a file with .lua extension, created in any text editor. After saving it can be executed in the lua interpreter using -l command line switch. For example:\nlua -l helloworld.lua Note: space after -l is optional.\nBecause the file is just one of chunks executed by Lua interpreter, you can execute many of chunks from different files using.\nFor example, when you have file file1.lua with content:\ns = \u0026#34;Hello world\u0026#34; and another file file2.lua with content:\nprint(s) Then you can load both chunks (Lua will use require) and last switch \u0026ldquo;-e\u0026rdquo; will make Lua interpreter exit after printing content of variable set in first chunk.\n% lua -lfile1 -lfile2 -e \u0026#34;os.exit(1)\u0026#34; Hello world Require statement\r#\rBecause chunks of statements might need another file or a lua module, Lua has function require. It tries to find the file in Lua Path and if it wasn\u0026rsquo;t loaded yet, it loads it. Now, lets consider we still have file1.lua which sets variable s to \u0026ldquo;Hello World\u0026rdquo;. We can create another file, for example called use_file1.lua with content:\nrequire(\u0026#34;file1\u0026#34;) print(s) Where the require function checks if module \u0026ldquo;file1\u0026rdquo; is already loaded, eventually loads it. The consequent print will reuse the defined variable and prints its content, so that output of this command will be Hello World. The command to execute with output:\n% lua -l use_file1 -e \u0026#34;os.exit(1)\u0026#34; Hello world Please note, that when loading a module with -l or require function, we dont specify the .lua extension. It is because of how Lua is resolving modules.\nLua first check if environment variable LUA_PATH exists, if it does, tries to extract path patterns from it. The file patterns is a list of paths to search for modules where ? can be used instead of part of file name. Standard paths which Lua searches in can be printed by:\n% lua -e \u0026#34;print(package.path)\u0026#34; /usr/local/share/lua/5.4/?.lua;/usr/local/share/lua/5.4/?/init.lua;/usr/local/lib/lua/5.4/?.lua;/usr/local/lib/lua/5.4/?/init.lua;./?.lua;./?/init.lua It is semicolon separated list of patterns. Most interestring is \u0026ldquo;./?.lua\u0026rdquo; which searches for file name specified in require (instead of ?) with .lua extension in current working directory.\nDofile function\r#\rSimilarly to require, dofile is a function which loads chunk of statements. But it doesn\u0026rsquo;t search for file in Lua Path. Because of this, extension is required. Also, dofile doesn\u0026rsquo;t check whether the file was loaded and loads it again always.\nTo execute same two chunks as we used above, we can use dofile like this:\n% lua -e \u0026#34;dofile(\u0026#39;file1.lua\u0026#39;) dofile(\u0026#39;file2.lua\u0026#39;) os.exit(1)\u0026#34; Hello world "},{"id":4,"href":"/lua-tutorial/docs/05-string-functions/","title":"05. String functions","section":"Docs","content":"\rMultiline string literals\r#\rTo set even very long strings, the literal can be placed among two square brackets [[\u0026hellip;]]. html = [[ \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ]] print(html) Execute \u0026raquo; String conversion\r#\rWhenever a string is used in an expression together with a number, Lua will attempt to convert string to its numerical value so that expression could have been evaluated. When this is not expected, it can lead to misleading result. print(\u0026#34;10\u0026#34;*2) print(\u0026#34;1\u0026#34;\u0026#43;\u0026#34;2\u0026#34;) Execute \u0026raquo; Please note that equality check with == will return false, because types doesn\u0026rsquo;t match. print(\u0026#34;1\u0026#34; == 1) Execute \u0026raquo; When this doesn\u0026rsquo;t succeed, it produces an Error. print(\u0026#34;one\u0026#34;\u0026#43;2) Execute \u0026raquo; Concatenation with ..\r#\rFor concatenate (join) two strings in a new string, use two dots ... This will prevent string conversion. Please note that used after a number, it needs to be separated by a space to distinguish it from a decimal point. Following code mixes non-space separated concatenation with separated for use after a number. print(\u0026#34;Day: \u0026#34;..1) print(type(1 .. 23 .. 45)) Execute \u0026raquo; Convert to number with tonumber\r#\rTo convert a string to a number, use tonumber. The function results in nil when the parameter is not a number. print(type(\u0026#34;123\u0026#34;)) print(type(tonumber(\u0026#34;456\u0026#34;))) print(tonumber(\u0026#34;two\u0026#34;)) Execute \u0026raquo; Get length of a string with # or len\r#\rTo find the number of characters in a string, Lua has special operator # used before the string. The followign example prints 3.\nlength = #\u0026#34;abc\u0026#34; print(length) The string library also defines metafunction __len for string. We will conver metafunctions later. The use is stringVar:len() or stringVar.len(stringVar) or string.len(stringVar). s = \u0026#34;abc\u0026#34; length1 = #s length2 = s.len(s) length3 = string.len(s) print(s, length1, length2, length3) Execute \u0026raquo; "},{"id":5,"href":"/lua-tutorial/docs/06-arrays/","title":"06. Arrays and tables","section":"Docs","content":"\rLua Arrays\r#\rThe Lua multi-purpose data type table is a base for Arrays. It is a collection of values with an index. To create a new array, we can use brackets {}. Arrays can grow dynamically, because they are based on tables. To set or get a value on a specific index, we use square brackets [] with index: [1] will return element at index 1 or nil if it doesn\u0026rsquo;t exist. Arrays can start from 0 or 1 or any other value. It is a convention to start arrays at index 1 and Lua libraries follows this convention. To insert a new value, we can assign new value to new index. A new array can be initialized with a literal in brackets.\na = {} a[2] = 1 odd = {1, 3, 5, 7} print(a[1], a[2]) print(odd[1], odd[2]) Execute \u0026raquo; Lua tables\r#\rData Type Table can not only be used for arrays with an integer index, but this concept is broad in Lua world. Instead of using numeric index, the index can be a string (or any other value except nil), like this:\na = {} a[\u0026#34;name\u0026#34;] = \u0026#34;Bob\u0026#34; print(a[\u0026#34;name\u0026#34;]) Execute \u0026raquo; Tables are implemented as associative arrays in other languages it is known as Dictionaries or Maps. They string index is called also a key and it must be unique (like the numeric index).\nBecause Lua uses tables a lot, it allows to refer to keys in the table also using without square brackets, like this:\na.name = \u0026#34;Bob\u0026#34; Tables are reference types, so assigning a table to another variable will reflect consequent changes on both places, because they are sharing same reference table.\nhobbit = {} hobbit.name = \u0026#34;Bilbo\u0026#34; invisibleHobbit = hobbit print(invisibleHobbit.name) Execute \u0026raquo; Lua tables can be also used as records and table initialization supports also construction with providing named fields. The table keys are also case sensitive. For example:\nperson = {Name=\u0026#34;John\u0026#34;, Lastname = \u0026#34;Doe\u0026#34;} print(person.Name, person.Lastname) Execute \u0026raquo; Lua tables as packages\r#\rLua uses tables to organize libraries loaded by require into packages. For example math.pi refers to Pi value declared in library math, which is automatically loaded by Lua and added to global scope.\nprint(math.pi) Execute \u0026raquo; Lua table indexes as variables\r#\rTable keys, or indexes can be also evaluated from a variable. In next example, we store two different values to different keys based on actual k value.\nchild = {} k = \u0026#34;age\u0026#34; child[k] = 5 k = \u0026#34;sleeping\u0026#34; child[k] = true print(child.age, child.sleeping) Execute \u0026raquo; "},{"id":6,"href":"/lua-tutorial/docs/07-functions-local-and-global-scope/","title":"07. Functions, local and global scope","section":"Docs","content":"\rFunctions\r#\rInstead of repeating some code block, or calling a dofile multiple times, we can use a function, which is an abstraction to structure a block of code.\nThese blocks are the same, except the variable n n = \u0026#34;Alice\u0026#34; s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) n = \u0026#34;Bob\u0026#34; s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) Execute \u0026raquo; It can be extracted into a function and give it a name SayHello and parameter n Because the functions contain multiple statements we need to use end keyword to indicate end of function. Function starts with function keyword, then its name and in parenthesis can be list of parameters for it. function SayHello(n) s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) end Execute \u0026raquo; Note: We will cover anonymous functions later.\nIf we execute this block alone, nothing will happen, because we have only declared (specified) the function and its statements, but we didn\u0026rsquo;t started it from anywhere. To call a function, we just type its name and within parenthesis provide a value for the parameters. function SayHello(n) s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) end SayHello(\u0026#34;Alice\u0026#34;) SayHello(\u0026#34;Bob\u0026#34;) Execute \u0026raquo; Local variables\r#\rActually the variable s in our function is a global variable. It means that it shares the value with the rest of the code even outside of the function block. That could lead to some unexpected variable changes when code is more complex. Instead, we can isolate variable to be only defined in the block of code. To do it, when we declare the variable we prefix it with local. For example:\nlocal s = \u0026#34;Hi, my name is\u0026#34; .. n Such a variable then won\u0026rsquo;t even exist outside of the function block, in the main program, or in another function. It is beneficial to use local variable as much as possible to prevent the variable clashes, but in Lua it needs to be explicitly expressed.\nGlobal variables and global scope\r#\rIf the local prefix is missing, the variable is considered global, which means it is shared among all blocks. The program which is not in any block is called global scope, in contrast code inside a function or other blocks is called local scope. Variables declared with local prefix exists only it its scope.\nIf you look at following code, you will see that variable s is at first outside of function. It wasn\u0026rsquo;t declared there, so at first it is nil. Later, from global scope we call function SayHello with parameter Alice, which sets variable from global scope to \u0026ldquo;Hi, my name is Alice\u0026rdquo; and because it is global scope variable, it will change its value even in main program and this texts is printed out. print(\u0026#34;Variable s in the beginning : \u0026#34;,s) function SayHello(n) s = \u0026#34;Hi, my name is \u0026#34; .. n print(s) end SayHello(\u0026#34;Alice\u0026#34;) print(\u0026#34;Variable s after SayHello(Alice) : \u0026#34;,s) SayHello(\u0026#34;Bob\u0026#34;) print(\u0026#34;Variable s after SayHello(Bob) : \u0026#34;,s) Execute \u0026raquo; Lua Global scope table\r#\rIn Lua, The global scope variables and functions are stored in special built-in table, called underscore G _G. For example we can access global variable directly throught the _G using: name = \u0026#34;Jack\u0026#34; age = 51 print(_G.name, _G.age) Execute \u0026raquo; "},{"id":7,"href":"/lua-tutorial/docs/08-functions-with-multiple-results/","title":"08. Functions with multiple results","section":"Docs","content":"\rFunctions with multiple results\r#\rIn Lua, function can return none, one, or even multiple return values. It is not the same as if function returns a table, here its results are stored directly to result variables after the call. For example hypothetical function to attempt to withdraw money could result in either whole amount, or just a portion of requested cash and an boolean indication that not whole requested value was returned. Our function for simplicity always results in true.\nfunction TryWithdrawMoney(m) return m, true end amount, success = TryWithdrawMoney(100) print(amount, success) Execute \u0026raquo; Lua changes behaviour of how multiple results are being used, depending into how many result variables the result is assigned to match the expected count. For example following code will fill result based on produced number of results and the rest will be nil.\nfunction Produce0() return end function Produce1() return \u0026#34;a\u0026#34; end function Produce2() return \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34; end x,y,z = Produce0() print(x,y,z) x,y,z = Produce1() print(x,y,z) x,y,z = Produce2() print(x,y,z) Execute \u0026raquo; Similarly, we can combine the multiple results producing function with multiple results assignment.\nfunction Produce0() return end function Produce1() return \u0026#34;a\u0026#34; end function Produce2() return \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34; end x,y,z = 1, 2, Produce0() print(x,y,z) x,y,z = Produce1() print(x,y,z) x,y,z = Produce1(), 1, 2 print(x,y,z) Execute \u0026raquo; There is a convention in Lua, if function returns value, which I don\u0026rsquo;t want to use we assign it to variable underscore _.\nCreate multiple results from an array\r#\rLua\u0026rsquo;s unpack function can accept an array as argument and returns the values are multiple value results. Following with fill result variables:\nx,y,z = unpack({1, 2, 3}) print(x,y,z) Execute \u0026raquo; Calling function with multiple parameters\r#\rWhen a function has multiple parameters, we can also use unpack to deconstruct its array argument into the parameters for the function:\nfunction add(a, b) return a\u0026#43;b end a = {1,2} print(add(unpack(a))) Execute \u0026raquo; "},{"id":8,"href":"/lua-tutorial/docs/09-closures-iterators/","title":"9. Closures and Iterators","section":"Docs","content":"\rReturn function from a function\r#\rA function result can also be a new function. This could be usefull when I dont want to immediatelly execute some code, but instead just provide a mechanism to create customized function to be evaluated later in my code. Typically such a function doesn\u0026rsquo;t have name, its called anonymous.\nFor example function makeCurrentTime returns a function, which has no parameters, and when called, it just returns what is in global string hardCodedTime. It could be used to mock current time for testing for example.\nPlease note that such a returned function can be immadiatelly called by providing parameters in brackets, so the calling code has two sets of brackets. First creates function and second calls it.\nfunction makeCurrentTime() return function () return hardcodedTime end end hardcodedTime = \u0026#34;12:15\u0026#34; nowFunction = makeCurrentTime() t = nowFunction() print(\u0026#34;The time is \u0026#34;, t) hardcodedTime = \u0026#34;02:00\u0026#34; nowFunction = makeCurrentTime() t = nowFunction() print(\u0026#34;The time is \u0026#34;, t) print(\u0026#34;Concise call with extra brackets \u0026#34;,makeCurrentTime()()) Execute \u0026raquo; Access outer state from a closure function\r#\rThe function returned from another function could also return local variable from the function where it is defined, this is possible due to mechanism called closure. The variables still have the value, even if the originating function has already returned and they values can be changed, providing different behaviour upon consequent closure function calls.\nPlease note that to keep closure\u0026rsquo;s state we have to create closure function once, but can call it multiple times.\nfunction endlessIncreaser() local a = 0 return function () a = a \u0026#43; 1 return a end end increaser = endlessIncreaser() print(\u0026#34;calling endlessIncreaser() \u0026#34;, increaser()) print(\u0026#34;calling endlessIncreaser() \u0026#34;, increaser()) Execute \u0026raquo; Lua iterators\r#\rIterator is an interestring function, which could provide next value from a table, sequence, or based on completelly customized logic. In its nature it is abstraction which allows write even more complex way how to provide next value, which can be later reused by other code more easily. Iterators in Lua are functions, which based on passed state generate next state. For example endlessIncreaser used above is already an iterator. Later in chapter 11-cycles-for-while-pairs/ we will see concise way how to consume values created by iterators.\n"},{"id":9,"href":"/lua-tutorial/docs/10-table-key-value-pairs/","title":"10. Table Key value pairs","section":"Docs","content":"\rKey value pairs\r#\rWe have mentioned that in table values are indexed by keys. Lua provides functions to return key and value from specific index as multiple results.\nPairs and IPairs functions\r#\rThe built-in functions pairs and ipairs works with tables. They provide iterators for all keys and values in the provided table.\nThe key difference is that\npairs provides actual key and value\nipairs provides real index - a number on which index the value is in the table, but doesn\u0026rsquo;t provide the key.\na = {[1]=\u0026#34;I\u0026#34;, [2]=\u0026#34;II\u0026#34;, [3]=\u0026#34;III\u0026#34;} currentKey = 1 -- create iterator iter, tableA = pairs(a) currentValue = tableA[currentKey] print(\u0026#34;Before call to iterator\u0026#34;) print(currentKey, currentValue) print(\u0026#34;Calling iterator to get next key and value\u0026#34;) currentKey, currentValue = iter(tableA, currentKey) print(currentKey, currentValue) Execute \u0026raquo; Please note, that the order of keys doesn\u0026rsquo;t match the index. When we create the iterator and call it to provide next key after key 1, we will get back third element of our table. This is intended behaviour.\nAlso, to use iterator of pairs, we need to know some existing key, or the first one.\nThe following example gets iterator using ipairs and creates next index and value pair.\nThe problem with ipairs is that it can iterate the table only when keys are numbers, so it cannot be used with string keys.\na = {[1]=\u0026#34;I\u0026#34;, [2]=\u0026#34;II\u0026#34;, [3]=\u0026#34;III\u0026#34;} firstKey, firstValue = ipairs(a)(a,0) print(firstKey, firstValue) firstKey, firstValue = ipairs(a)(a,firstKey) print(firstKey, firstValue) Execute \u0026raquo; "},{"id":10,"href":"/lua-tutorial/docs/11-cycles-for-while-pairs/","title":"11. Cycles for and while","section":"Docs","content":"\rCycle structures\r#\rSimilarly to other languages Lua has statement for controlling repetitive cycle which might have a variable to drive it and a condition at the beginning or end of the cycle.\nFor cycle\r#\rLua has two for types of cycles, numeric for and generic for.\nNumeric for cycle\r#\rTo execute some statement several times, without for cycle we would need to declare variable with initial value, adjust the variable for next value up the the maximal range and execute the defined block.\nFor cycle has following form, where newly declared local variable i will have values from 1 to 3 (inclusive).\nfor i=1, 3 do print(\u0026#34;*\u0026#34;, i) end Execute \u0026raquo; In this form, variable is incremented by one and if we want different increment, we can add it after the end of range. In this form, cycle will start with 3 and decrease down up to 1. for i=3, 1, -1 do print(\u0026#34;*\u0026#34;, i) end Execute \u0026raquo; Generic for cycle\r#\rIn Lua, generic for cycle is for iterating over iterators. The most common use case is to iterate over tables using function pairs or ipairs, which are providing built in iterators over tables. The syntax is as following:\na = {January=31,February=28, March=31} for k, m in pairs(a) do print(k..\u0026#34; has \u0026#34;..m..\u0026#34; days\u0026#34;) end Execute \u0026raquo; The use of ipairs which returns index and value is similar and actually any iterator can be used in generic for same way.\nsuffixes = {[1]=\u0026#34;st\u0026#34;,[2]=\u0026#34;nd\u0026#34;,[3]=\u0026#34;rd\u0026#34;} a = {[1]=\u0026#34;January\u0026#34;,[2]=\u0026#34;February\u0026#34;,[3]=\u0026#34;March\u0026#34;} for i, v in ipairs(a) do print(i..\u0026#34; \u0026#34;..suffixes[i]..\u0026#34; month is \u0026#34;..v) end Execute \u0026raquo; "},{"id":11,"href":"/lua-tutorial/docs/12-common-standard-libraries-copy/","title":"12. Common standard libraries","section":"Docs","content":"\rPreloaded libraries\r#\rString library\r#\rTo set even very long strings, the literal can be placed among two square brackets [[\u0026hellip;]]. html = [[ \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ]] print(html) Execute \u0026raquo; String conversion\r#\rWhenever a string is used in an expression together with a number, Lua will attempt to convert string to its numerical value so that expression could have been evaluated. When this is not expected, it can lead to misleading result. print(\u0026#34;10\u0026#34;*2) print(\u0026#34;1\u0026#34;\u0026#43;\u0026#34;2\u0026#34;) Execute \u0026raquo; Please note that equality check with == will return false, because types doesn\u0026rsquo;t match. print(\u0026#34;1\u0026#34; == 1) Execute \u0026raquo; When this doesn\u0026rsquo;t succeed, it produces an Error. print(\u0026#34;one\u0026#34;\u0026#43;2) Execute \u0026raquo; Concatenation with ..\r#\rFor concatenate (join) two strings in a new string, use two dots ... This will prevent string conversion. Please note that used after a number, it needs to be separated by a space to distinguish it from a decimal point. Following code mixes non-space separated concatenation with separated for use after a number. print(\u0026#34;Day: \u0026#34;..1) print(type(1 .. 23 .. 45)) Execute \u0026raquo; Convert to number with tonumber\r#\rTo convert a string to a number, use tonumber. The function results in nil when the parameter is not a number. print(type(\u0026#34;123\u0026#34;)) print(type(tonumber(\u0026#34;456\u0026#34;))) print(tonumber(\u0026#34;two\u0026#34;)) Execute \u0026raquo; Get length of a string with # or len\r#\rTo find the number of characters in a string, Lua has special operator # used before the string. The followign example prints 3.\nlength = #\u0026#34;abc\u0026#34; print(length) The string library also defines metafunction __len for string. We will conver metafunctions later. The use is stringVar:len() or stringVar.len(stringVar) or string.len(stringVar). s = \u0026#34;abc\u0026#34; length1 = #s length2 = s.len(s) length3 = string.len(s) print(s, length1, length2, length3) Execute \u0026raquo; "}]