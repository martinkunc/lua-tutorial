<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Key value pairs#We have mentioned that in table values are indexed by keys. Lua provides functions to return key and value from specific index as multiple results.
Pairs and IPairs functions#The built-in functions pairs and ipairs works with tables. They provide iterators for all keys and values in the provided table.
The key difference is in result which each iterator returns
pairs creates iterator which provides current key and value"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="11. Table Key value pairs"><meta property="og:description" content="Key value pairs#We have mentioned that in table values are indexed by keys. Lua provides functions to return key and value from specific index as multiple results.
Pairs and IPairs functions#The built-in functions pairs and ipairs works with tables. They provide iterators for all keys and values in the provided table.
The key difference is in result which each iterator returns
pairs creates iterator which provides current key and value"><meta property="og:type" content="article"><meta property="og:url" content="https://martinkunc.github.io/lua-tutorial/docs/11-table-key-value-pairs/"><meta property="article:section" content="docs"><title>11. Table Key value pairs | Lua tutorial</title><link rel=manifest href=/lua-tutorial/manifest.json><link rel=icon href=/lua-tutorial/favicon.png type=image/x-icon><link rel=stylesheet href=/lua-tutorial/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/lua-tutorial/flexsearch.min.js></script>
<script defer src=/lua-tutorial/en.search.min.ac70413d1902211a5e9ddd055b0b1e33a261dab2aa9fa7814176408b1773acb9.js integrity="sha256-rHBBPRkCIRpend0FWwseM6Jh2rKqn6eBQXZAixdzrLk=" crossorigin=anonymous></script>
<script src=https://martinkunc.github.io/lua-tutorial//js/lua.vm.js?1662349164></script>
<link rel=stylesheet href=https://martinkunc.github.io/lua-tutorial//css/codemirror.css?1662349164><script src=https://martinkunc.github.io/lua-tutorial//js/codemirror.js?1662349164></script>
<link rel=stylesheet href=https://martinkunc.github.io/lua-tutorial//css/styles.css?1662349164><script src=https://martinkunc.github.io/lua-tutorial//js/lua.js?1662349164></script>
<script src=https://martinkunc.github.io/lua-tutorial//js/luacode.js?1662349164></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/lua-tutorial/><span>Lua tutorial</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/lua-tutorial/docs/01-installation/>01. Installation</a></li><li><a href=/lua-tutorial/docs/02-introduction/>02. Introduction</a></li><li><a href=/lua-tutorial/docs/03-types/>03. Types</a></li><li><a href=/lua-tutorial/docs/04-chunks-and-require/>04. Chunks and require</a></li><li><a href=/lua-tutorial/docs/05-string-functions/>05. String functions</a></li><li><a href=/lua-tutorial/docs/06-arrays/>06. Arrays and tables</a></li><li><a href=/lua-tutorial/docs/07-if-condition-operators/>07. If condition and operators</a></li><li><a href=/lua-tutorial/docs/08-functions-local-and-global-scope/>08. Functions, local and global scope</a></li><li><a href=/lua-tutorial/docs/09-functions-with-multiple-results/>09. Functions with multiple results</a></li><li><a href=/lua-tutorial/docs/10-closures-iterators/>10. Closures and Iterators</a></li><li><a href=/lua-tutorial/docs/11-table-key-value-pairs/ class=active>11. Table Key value pairs</a></li><li><a href=/lua-tutorial/docs/12-for-cycle/>12. For Cycle</a></li><li><a href=/lua-tutorial/docs/13-while-and-repeat-cycles/>13. While and repeat cycles</a></li><li><a href=/lua-tutorial/docs/15-common-standard-libraries-copy/>15. Common standard libraries</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/lua-tutorial/svg/menu.svg class=book-icon alt=Menu></label>
<strong>11. Table Key value pairs</strong>
<label for=toc-control></label></div></header><article class=markdown><h2 id=key-value-pairs>Key value pairs
<a class=anchor href=#key-value-pairs>#</a></h2><p>We have mentioned that in table values are indexed by keys. Lua provides functions to return key and value from specific index as multiple results.</p><h2 id=pairs-and-ipairs-functions>Pairs and IPairs functions
<a class=anchor href=#pairs-and-ipairs-functions>#</a></h2><p>The built-in functions <code>pairs</code> and <code>ipairs</code> works with tables. They provide iterators for all keys and values in the provided table.</p><p>The key difference is in result which each iterator returns</p><p><code>pairs</code> creates iterator which provides current key and value</p><p><code>ipairs</code> provides two results, the current key (index) in the table and also the value on the key in the table</p><h3 id=stateless-and-statefull-iterators>Stateless and statefull iterators
<a class=anchor href=#stateless-and-statefull-iterators>#</a></h3><p>Both pairs and iparis are examples of stateless operators. That means there is no hidden state and its execution is entirely driven by provided control variable (current key).</p><p>Example of statefull operator is shown in chapter <a href=/lua-tutorial/09-closures-iterators>09. Closures and Iterators</a> in function <code>endlessIncreaser</code>, which remembers its state and doesn&rsquo;t require control variable.</p><p>Stateless iterators have to continue from a certain point in the collection so to obtain next value from an iterator we need to provide it the current value.
Usually the next returned value then becomes new current value.</p><p>To find the first item, initial iterator can be called without the current state and that is why number of arguments to <code>iter</code> differs in first call here:</p><div class=grid-container><div class=grid-item><textarea class=editor>
a = {[1]=&#34;I&#34;, [2]=&#34;II&#34;, [3]=&#34;III&#34;}
-- create iterator
iter = pairs(a)

print(&#34;Calling iterator first time &#34;)
currentKey, currentValue = iter(a)
print(currentKey, currentValue)

print(&#34;Calling iterator second time&#34;)
currentKey, currentValue = iter(a, currentKey)
print(currentKey, currentValue)

print(&#34;Calling iterator third time&#34;)
currentKey, currentValue = iter(a, currentKey)
print(currentKey, currentValue)

print(&#34;Calling iterator fourth time&#34;)
currentKey, currentValue = iter(a, currentKey)
print(currentKey, currentValue)
</textarea><div class=rowexecute><div class=execute><a href=# class=executeButton>Execute &#187;</a></div></div></div><div class=grid-item><div class=output><pre class=outputText></pre></div></div><script>attachCode(document.currentScript)</script></div><p>Please note, that the order of keys is not guarantueed to match the constructor. If we would need the ordered enumeration, we would need to iterate over the index.</p><p>The following example gets iterator using <code>ipairs</code> and creates next index and value pair.</p><p>The problem with ipairs is that it can iterate the table only when keys are numbers, so it cannot be used with string keys.</p><p>Another limitation of ipairs is that you have to provide it with initial key, but that is returned as third result of <code>ipairs</code>.</p><p>The second result <code>state</code> is the invariant table being used to iterate over. This is usefull when the state of iteration is complex, so that the iterator can create control table with state, which would use to drive iterations together with control variable.</p><div class=grid-container><div class=grid-item><textarea class=editor>
a = {[1]=&#34;I&#34;, [2]=&#34;II&#34;, [3]=&#34;III&#34;}

iter, state, initial = ipairs(a)

nextKey, nextValue = iter(a,initial)
print(&#34;1st call Key &#34;, nextKey,&#34; value &#34;, nextValue)

nextKey, nextValue = iter(a,nextKey)
print(&#34;2nd call Key &#34;, nextKey,&#34; value &#34;, nextValue)

nextKey, nextValue = iter(a,nextKey)
print(&#34;3nd call Key &#34;, nextKey,&#34; value &#34;, nextValue)

nextKey, nextValue = iter(a,nextKey)
print(&#34;4th call Key &#34;, nextKey,&#34; value &#34;, nextValue)

</textarea><div class=rowexecute><div class=execute><a href=# class=executeButton>Execute &#187;</a></div></div></div><div class=grid-item><div class=output><pre class=outputText></pre></div></div><script>attachCode(document.currentScript)</script></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>