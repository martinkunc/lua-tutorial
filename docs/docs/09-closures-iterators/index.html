<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Return function from a function#A function result can also be a new function. This could be usefull when I dont want to immediatelly execute some code, but instead just provide a mechanism to create customized function to be evaluated later in my code. Typically such a function doesn&rsquo;t have name, its called anonymous.
For example function makeCurrentTime returns a function, which has no parameters, and when called, it just returns what is in global string hardCodedTime."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="9. Closures and Iterators"><meta property="og:description" content="Return function from a function#A function result can also be a new function. This could be usefull when I dont want to immediatelly execute some code, but instead just provide a mechanism to create customized function to be evaluated later in my code. Typically such a function doesn&rsquo;t have name, its called anonymous.
For example function makeCurrentTime returns a function, which has no parameters, and when called, it just returns what is in global string hardCodedTime."><meta property="og:type" content="article"><meta property="og:url" content="https://martinkunc.github.io/lua-tutorial/docs/09-closures-iterators/"><meta property="article:section" content="docs"><title>9. Closures and Iterators | Lua tutorial</title><link rel=manifest href=/lua-tutorial/manifest.json><link rel=icon href=/lua-tutorial/favicon.png type=image/x-icon><link rel=stylesheet href=/lua-tutorial/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/lua-tutorial/flexsearch.min.js></script>
<script defer src=/lua-tutorial/en.search.min.1e53d776e105d3b82bf6e80c3909b4ff025c4abea186664eaf15b11daa1cfe76.js integrity="sha256-HlPXduEF07gr9ugMOQm0/wJcSr6hhmZOrxWxHaoc/nY=" crossorigin=anonymous></script>
<script src=https://martinkunc.github.io/lua-tutorial//js/lua.vm.js?1661709686></script>
<link rel=stylesheet href=https://martinkunc.github.io/lua-tutorial//css/codemirror.css?1661709686><script src=https://martinkunc.github.io/lua-tutorial//js/codemirror.js?1661709686></script>
<link rel=stylesheet href=https://martinkunc.github.io/lua-tutorial//css/styles.css?1661709686><script src=https://martinkunc.github.io/lua-tutorial//js/lua.js?1661709686></script>
<script src=https://martinkunc.github.io/lua-tutorial//js/luacode.js?1661709686></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/lua-tutorial/><span>Lua tutorial</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/lua-tutorial/docs/01-installation/>01. Installation</a></li><li><a href=/lua-tutorial/docs/02-introduction/>02. Introduction</a></li><li><a href=/lua-tutorial/docs/03-types/>03. Types</a></li><li><a href=/lua-tutorial/docs/04-chunks-and-require/>04. Chunks and require</a></li><li><a href=/lua-tutorial/docs/05-string-functions/>05. String functions</a></li><li><a href=/lua-tutorial/docs/06-arrays/>06. Arrays and tables</a></li><li><a href=/lua-tutorial/docs/07-functions-local-and-global-scope/>07. Functions, local and global scope</a></li><li><a href=/lua-tutorial/docs/08-functions-with-multiple-results/>08. Functions with multiple results</a></li><li><a href=/lua-tutorial/docs/09-closures-iterators/ class=active>9. Closures and Iterators</a></li><li><a href=/lua-tutorial/docs/10-table-key-value-pairs/>10. Table Key value pairs</a></li><li><a href=/lua-tutorial/docs/11-cycles-for-while-pairs/>11. Cycles for and while</a></li><li><a href=/lua-tutorial/docs/12-common-standard-libraries-copy/>12. Common standard libraries</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/lua-tutorial/svg/menu.svg class=book-icon alt=Menu></label>
<strong>9. Closures and Iterators</strong>
<label for=toc-control></label></div></header><article class=markdown><h2 id=return-function-from-a-function>Return function from a function
<a class=anchor href=#return-function-from-a-function>#</a></h2><p>A function result can also be a new function. This could be usefull when I dont want to immediatelly execute some code, but instead just provide a mechanism to create customized function to be evaluated later in my code.
Typically such a function doesn&rsquo;t have name, its called anonymous.</p><p>For example function makeCurrentTime returns a function, which has no parameters, and when called, it just returns what is in global string hardCodedTime. It could be used to mock current time for testing for example.</p><p>Please note that such a returned function can be immadiatelly called by providing parameters in brackets, so the calling code has two sets of brackets. First creates function and second calls it.</p><div class=grid-container><div class=grid-item><textarea class=editor>
function makeCurrentTime() 
  return function ()
    return hardcodedTime
  end
end

hardcodedTime = &#34;12:15&#34;
nowFunction = makeCurrentTime()
t = nowFunction()
print(&#34;The time is &#34;, t)

hardcodedTime = &#34;02:00&#34;
nowFunction = makeCurrentTime()
t = nowFunction()
print(&#34;The time is &#34;, t)

print(&#34;Concise call with extra brackets &#34;,makeCurrentTime()())
</textarea><div class=rowexecute><div class=execute><a href=# class=executeButton>Execute &#187;</a></div></div></div><div class=grid-item><div class=output><pre class=outputText></pre></div></div><script>attachCode(document.currentScript)</script></div><h2 id=access-outer-state-from-a-closure-function>Access outer state from a closure function
<a class=anchor href=#access-outer-state-from-a-closure-function>#</a></h2><p>The function returned from another function could also return local variable from the function where it is defined, this is possible due to mechanism called closure. The variables still have the value, even if the originating function has already returned and they values can be changed, providing different behaviour upon consequent closure function calls.</p><p>Please note that to keep closure&rsquo;s state we have to create closure function once, but can call it multiple times.</p><div class=grid-container><div class=grid-item><textarea class=editor>
function endlessIncreaser()
  local a = 0 
  return function ()
    a = a &#43; 1
    return a
  end
end

increaser = endlessIncreaser()
print(&#34;calling endlessIncreaser() &#34;, increaser())

print(&#34;calling endlessIncreaser() &#34;, increaser())
</textarea><div class=rowexecute><div class=execute><a href=# class=executeButton>Execute &#187;</a></div></div></div><div class=grid-item><div class=output><pre class=outputText></pre></div></div><script>attachCode(document.currentScript)</script></div><h2 id=lua-iterators>Lua iterators
<a class=anchor href=#lua-iterators>#</a></h2><p>Iterator is an interestring function, which could provide next value from a table, sequence, or based on completelly customized logic. In its nature it is abstraction which allows write even more complex way how to provide next value, which can be later reused by other code more easily.
Iterators in Lua are functions, which based on passed state generate next state.
For example endlessIncreaser used above is already an iterator. Later in <a href=/lua-tutorial/docs/11-cycles-for-while-pairs/>chapter 11-cycles-for-while-pairs/</a> we will see concise way how to consume values created by iterators.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>